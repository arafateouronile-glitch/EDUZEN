{"version":3,"sources":["../../../node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts","../../../lib/supabase/client.ts/__nextjs-internal-proxy.mjs","../../../lib/errors/error-handler.ts","../../../lib/services/signature.service.ts","../../../lib/services/esignature-webhook-handler.service.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const createClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call createClient() from the server but createClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/lib/supabase/client.ts\",\n    \"createClient\",\n);\n","/**\n * ErrorHandler Global - Gestion centralisée des erreurs\n * \n * Fournit :\n * - Types d'erreurs personnalisés\n * - Classification automatique des erreurs\n * - Messages utilisateur traduits\n * - Logging automatique\n * - Formatage cohérent\n */\n\nimport { logger } from '@/lib/utils/logger'\nimport type { LogContext } from '@/lib/utils/logger'\n\n// ============================================================================\n// TYPES D'ERREURS PERSONNALISÉS\n// ============================================================================\n\nexport enum ErrorCode {\n  // Erreurs d'authentification (1000-1999)\n  AUTH_REQUIRED = 'AUTH_1001',\n  AUTH_INVALID_CREDENTIALS = 'AUTH_1002',\n  AUTH_SESSION_EXPIRED = 'AUTH_1003',\n  AUTH_INSUFFICIENT_PERMISSIONS = 'AUTH_1004',\n  AUTH_2FA_REQUIRED = 'AUTH_1005',\n  AUTH_2FA_INVALID = 'AUTH_1006',\n\n  // Erreurs de validation (2000-2999)\n  VALIDATION_ERROR = 'VALID_2001',\n  VALIDATION_REQUIRED_FIELD = 'VALID_2002',\n  VALIDATION_INVALID_FORMAT = 'VALID_2003',\n  VALIDATION_UNIQUE_CONSTRAINT = 'VALID_2004',\n\n  // Erreurs de base de données (3000-3999)\n  DB_CONNECTION_ERROR = 'DB_3001',\n  DB_QUERY_ERROR = 'DB_3002',\n  DB_NOT_FOUND = 'DB_3003',\n  DB_CONSTRAINT_VIOLATION = 'DB_3004',\n  DB_FOREIGN_KEY_CONSTRAINT = 'DB_3006',\n  DB_RLS_POLICY_VIOLATION = 'DB_3005',\n\n  // Erreurs réseau/API (4000-4999)\n  NETWORK_ERROR = 'NET_4001',\n  API_TIMEOUT = 'NET_4002',\n  API_RATE_LIMIT = 'NET_4003',\n  API_SERVER_ERROR = 'NET_4004',\n  API_NOT_FOUND = 'NET_4005',\n  API_BAD_REQUEST = 'NET_4006',\n\n  // Erreurs métier (5000-5999)\n  BUSINESS_LOGIC_ERROR = 'BIZ_5001',\n  RESOURCE_LOCKED = 'BIZ_5002',\n  OPERATION_NOT_ALLOWED = 'BIZ_5003',\n  QUOTA_EXCEEDED = 'BIZ_5004',\n\n  // Erreurs système (6000-6999)\n  INTERNAL_ERROR = 'SYS_6001',\n  CONFIGURATION_ERROR = 'SYS_6002',\n  SERVICE_UNAVAILABLE = 'SYS_6003',\n}\n\nexport enum ErrorSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical',\n}\n\nexport interface AppErrorContext extends LogContext {\n  code?: ErrorCode\n  severity?: ErrorSeverity\n  userMessage?: string\n  retryable?: boolean\n  timestamp?: string\n}\n\n/**\n * Classe d'erreur personnalisée pour l'application\n */\nexport class AppError extends Error {\n  public readonly code: ErrorCode\n  public readonly severity: ErrorSeverity\n  public readonly userMessage: string\n  public readonly retryable: boolean\n  public readonly context: AppErrorContext\n  public readonly originalError?: Error | unknown\n\n  constructor(\n    message: string,\n    code: ErrorCode = ErrorCode.INTERNAL_ERROR,\n    severity: ErrorSeverity = ErrorSeverity.MEDIUM,\n    context: AppErrorContext = {},\n    originalError?: Error | unknown\n  ) {\n    super(message)\n    this.name = 'AppError'\n    this.code = code\n    this.severity = severity\n    this.userMessage = context.userMessage || this.getDefaultUserMessage(code)\n    this.retryable = context.retryable ?? this.isRetryable(code)\n    this.context = {\n      ...context,\n      code,\n      severity,\n      timestamp: new Date().toISOString(),\n    }\n    this.originalError = originalError\n\n    // Maintenir la stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AppError)\n    }\n  }\n\n  /**\n   * Messages utilisateur par défaut selon le code d'erreur\n   */\n  private getDefaultUserMessage(code: ErrorCode): string {\n    const messages: Record<ErrorCode, string> = {\n      // Auth\n      [ErrorCode.AUTH_REQUIRED]: 'Vous devez être connecté pour effectuer cette action.',\n      [ErrorCode.AUTH_INVALID_CREDENTIALS]: 'Email ou mot de passe incorrect.',\n      [ErrorCode.AUTH_SESSION_EXPIRED]: 'Votre session a expiré. Veuillez vous reconnecter.',\n      [ErrorCode.AUTH_INSUFFICIENT_PERMISSIONS]: \"Vous n'avez pas les permissions nécessaires.\",\n      [ErrorCode.AUTH_2FA_REQUIRED]: 'Authentification à deux facteurs requise.',\n      [ErrorCode.AUTH_2FA_INVALID]: 'Code d\\'authentification invalide.',\n\n      // Validation\n      [ErrorCode.VALIDATION_ERROR]: 'Les données fournies ne sont pas valides.',\n      [ErrorCode.VALIDATION_REQUIRED_FIELD]: 'Certains champs obligatoires sont manquants.',\n      [ErrorCode.VALIDATION_INVALID_FORMAT]: 'Le format des données est incorrect.',\n      [ErrorCode.VALIDATION_UNIQUE_CONSTRAINT]: 'Cette valeur existe déjà.',\n\n      // Database\n      [ErrorCode.DB_CONNECTION_ERROR]: 'Impossible de se connecter à la base de données.',\n      [ErrorCode.DB_QUERY_ERROR]: 'Erreur lors de l\\'exécution de la requête.',\n      [ErrorCode.DB_NOT_FOUND]: 'Ressource introuvable.',\n      [ErrorCode.DB_CONSTRAINT_VIOLATION]: 'Cette opération viole une contrainte de la base de données.',\n      [ErrorCode.DB_FOREIGN_KEY_CONSTRAINT]: 'Cette opération viole une contrainte de clé étrangère.',\n      [ErrorCode.DB_RLS_POLICY_VIOLATION]: 'Vous n\\'avez pas accès à cette ressource.',\n\n      // Network\n      [ErrorCode.NETWORK_ERROR]: 'Erreur de connexion réseau. Vérifiez votre connexion internet.',\n      [ErrorCode.API_TIMEOUT]: 'La requête a pris trop de temps. Veuillez réessayer.',\n      [ErrorCode.API_RATE_LIMIT]: 'Trop de requêtes. Veuillez patienter quelques instants.',\n      [ErrorCode.API_SERVER_ERROR]: 'Erreur serveur. Veuillez réessayer plus tard.',\n      [ErrorCode.API_NOT_FOUND]: 'Ressource introuvable.',\n      [ErrorCode.API_BAD_REQUEST]: 'Requête invalide.',\n\n      // Business\n      [ErrorCode.BUSINESS_LOGIC_ERROR]: 'Cette opération n\\'est pas autorisée dans le contexte actuel.',\n      [ErrorCode.RESOURCE_LOCKED]: 'Cette ressource est actuellement verrouillée.',\n      [ErrorCode.OPERATION_NOT_ALLOWED]: 'Cette opération n\\'est pas autorisée.',\n      [ErrorCode.QUOTA_EXCEEDED]: 'Vous avez atteint la limite autorisée.',\n\n      // System\n      [ErrorCode.INTERNAL_ERROR]: 'Une erreur interne est survenue. Veuillez réessayer.',\n      [ErrorCode.CONFIGURATION_ERROR]: 'Erreur de configuration du système.',\n      [ErrorCode.SERVICE_UNAVAILABLE]: 'Service temporairement indisponible.',\n    }\n\n    return messages[code] || 'Une erreur inattendue est survenue.'\n  }\n\n  /**\n   * Détermine si une erreur est retryable selon son code\n   */\n  private isRetryable(code: ErrorCode): boolean {\n    const retryableCodes = [\n      ErrorCode.NETWORK_ERROR,\n      ErrorCode.API_TIMEOUT,\n      ErrorCode.API_SERVER_ERROR,\n      ErrorCode.DB_CONNECTION_ERROR,\n      ErrorCode.SERVICE_UNAVAILABLE,\n    ]\n    return retryableCodes.includes(code)\n  }\n\n  /**\n   * Convertit l'erreur en objet JSON pour logging\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      severity: this.severity,\n      userMessage: this.userMessage,\n      retryable: this.retryable,\n      context: this.context,\n      stack: this.stack,\n      originalError: this.originalError instanceof Error\n        ? {\n            name: this.originalError.name,\n            message: this.originalError.message,\n            stack: this.originalError.stack,\n          }\n        : this.originalError,\n    }\n  }\n}\n\n// ============================================================================\n// ERROR HANDLER PRINCIPAL\n// ============================================================================\n\nexport class ErrorHandler {\n  /**\n   * Analyse et classe une erreur inconnue\n   */\n  handleError(error: unknown, context: AppErrorContext = {}): AppError {\n    // Si c'est déjà une AppError, la retourner telle quelle\n    if (error instanceof AppError) {\n      this.logError(error)\n      return error\n    }\n\n    // Si c'est une Error standard, la convertir\n    if (error instanceof Error) {\n      return this.handleStandardError(error, context)\n    }\n\n    // Si c'est une erreur Supabase\n    if (this.isSupabaseError(error)) {\n      return this.handleSupabaseError(error, context)\n    }\n\n    // Erreur inconnue\n    const appError = new AppError(\n      'Une erreur inattendue est survenue.',\n      ErrorCode.INTERNAL_ERROR,\n      ErrorSeverity.HIGH,\n      context,\n      error\n    )\n    this.logError(appError)\n    return appError\n  }\n\n  /**\n   * Gère les erreurs Error standard\n   */\n  private handleStandardError(error: Error, context: AppErrorContext): AppError {\n    const message = error.message.toLowerCase()\n\n    // Détection par message\n    let code = ErrorCode.INTERNAL_ERROR\n    let severity = ErrorSeverity.MEDIUM\n\n    if (message.includes('network') || message.includes('fetch')) {\n      code = ErrorCode.NETWORK_ERROR\n      severity = ErrorSeverity.MEDIUM\n    } else if (message.includes('timeout')) {\n      code = ErrorCode.API_TIMEOUT\n      severity = ErrorSeverity.MEDIUM\n    } else if (message.includes('unauthorized') || message.includes('401')) {\n      code = ErrorCode.AUTH_REQUIRED\n      severity = ErrorSeverity.HIGH\n    } else if (message.includes('forbidden') || message.includes('403')) {\n      code = ErrorCode.AUTH_INSUFFICIENT_PERMISSIONS\n      severity = ErrorSeverity.HIGH\n    } else if (message.includes('not found') || message.includes('404')) {\n      code = ErrorCode.DB_NOT_FOUND\n      severity = ErrorSeverity.LOW\n    } else if (message.includes('validation') || message.includes('invalid')) {\n      code = ErrorCode.VALIDATION_ERROR\n      severity = ErrorSeverity.LOW\n    }\n\n    const appError = new AppError(error.message, code, severity, context, error)\n    this.logError(appError)\n    return appError\n  }\n\n  /**\n   * Gère les erreurs Supabase\n   */\n  private handleSupabaseError(error: any, context: AppErrorContext): AppError {\n    const code = error.code || error.status\n    const message = error.message || 'Erreur Supabase'\n\n    // Si un code d'erreur est fourni dans le contexte, l'utiliser en priorité\n    let errorCode = context.code || ErrorCode.DB_QUERY_ERROR\n    let severity = ErrorSeverity.MEDIUM\n\n    // Classification par code Supabase (seulement si pas de code dans le contexte)\n    if (!context.code) {\n      switch (code) {\n        case 'PGRST116':\n        case '42P01':\n          errorCode = ErrorCode.DB_NOT_FOUND\n          severity = ErrorSeverity.LOW\n          break\n        case '42501':\n          errorCode = ErrorCode.DB_RLS_POLICY_VIOLATION\n          severity = ErrorSeverity.HIGH\n          break\n        case '23505':\n          errorCode = ErrorCode.VALIDATION_UNIQUE_CONSTRAINT\n          severity = ErrorSeverity.LOW\n          break\n        case '23503':\n          errorCode = ErrorCode.DB_CONSTRAINT_VIOLATION\n          severity = ErrorSeverity.MEDIUM\n          break\n        case 'PGRST301':\n        case '400':\n          errorCode = ErrorCode.API_BAD_REQUEST\n          severity = ErrorSeverity.LOW\n          break\n        case '401':\n          errorCode = ErrorCode.AUTH_REQUIRED\n          severity = ErrorSeverity.HIGH\n          break\n        case '403':\n          errorCode = ErrorCode.AUTH_INSUFFICIENT_PERMISSIONS\n          severity = ErrorSeverity.HIGH\n          break\n        case '404':\n          errorCode = ErrorCode.API_NOT_FOUND\n          severity = ErrorSeverity.LOW\n          break\n        case '500':\n          errorCode = ErrorCode.API_SERVER_ERROR\n          severity = ErrorSeverity.HIGH\n          break\n      }\n    }\n\n    // Ajuster la sévérité selon le code d'erreur\n    if (errorCode === ErrorCode.DB_FOREIGN_KEY_CONSTRAINT) {\n      severity = ErrorSeverity.MEDIUM\n    }\n\n    const appError = new AppError(message, errorCode, severity, context, error)\n    this.logError(appError)\n    return appError\n  }\n\n  /**\n   * Vérifie si une erreur est une erreur Supabase\n   */\n  private isSupabaseError(error: any): boolean {\n    return (\n      error &&\n      (error.code || error.status || error.message) &&\n      (typeof error.code === 'string' || typeof error.status === 'number')\n    )\n  }\n\n  /**\n   * Log l'erreur selon sa sévérité\n   */\n  private logError(error: AppError) {\n    const logContext: LogContext = {\n      ...error.context,\n      code: error.code,\n      severity: error.severity,\n      retryable: error.retryable,\n    }\n\n    switch (error.severity) {\n      case ErrorSeverity.CRITICAL:\n      case ErrorSeverity.HIGH:\n        logger.error(error.message, error.originalError || error, logContext)\n        break\n      case ErrorSeverity.MEDIUM:\n        logger.warn(error.message, logContext)\n        break\n      case ErrorSeverity.LOW:\n        logger.info(`Error: ${error.message}`, logContext)\n        break\n    }\n  }\n\n  /**\n   * Crée une erreur de validation\n   */\n  createValidationError(message: string, field?: string): AppError {\n    return new AppError(\n      message,\n      ErrorCode.VALIDATION_ERROR,\n      ErrorSeverity.LOW,\n      { field, userMessage: message }\n    )\n  }\n\n  /**\n   * Crée une erreur d'authentification\n   */\n  createAuthError(code: ErrorCode, message?: string): AppError {\n    return new AppError(\n      message || 'Erreur d\\'authentification',\n      code,\n      ErrorSeverity.HIGH\n    )\n  }\n\n  /**\n   * Crée une erreur de base de données\n   */\n  createDatabaseError(message: string, originalError?: unknown): AppError {\n    return new AppError(\n      message,\n      ErrorCode.DB_QUERY_ERROR,\n      ErrorSeverity.MEDIUM,\n      {},\n      originalError\n    )\n  }\n\n  /**\n   * Crée une erreur \"Not Found\"\n   */\n  createNotFoundError(message: string, context?: AppErrorContext): AppError {\n    return new AppError(\n      message,\n      ErrorCode.DB_NOT_FOUND,\n      ErrorSeverity.LOW,\n      context\n    )\n  }\n}\n\n// Export d'une instance singleton\nexport const errorHandler = new ErrorHandler()\n\n// Export de fonctions helper pour faciliter l'utilisation\nexport const handleError = (error: unknown, context?: AppErrorContext) =>\n  errorHandler.handleError(error, context)\n\nexport const createValidationError = (message: string, field?: string) =>\n  errorHandler.createValidationError(message, field)\n\nexport const createAuthError = (code: ErrorCode, message?: string) =>\n  errorHandler.createAuthError(code, message)\n\nexport const createDatabaseError = (message: string, originalError?: unknown) =>\n  errorHandler.createDatabaseError(message, originalError)\n\nexport const createNotFoundError = (message: string, context?: AppErrorContext) =>\n  errorHandler.createNotFoundError(message, context)\n\n// Alias pour NotFoundError (compatibilité)\nexport const NotFoundError = createNotFoundError\n\n","import { createClient } from '@/lib/supabase/client'\nimport type { SupabaseClient } from '@supabase/supabase-js'\nimport { Database } from '@/types/database.types'\nimport type { TableRow, TableInsert, TableUpdate, FlexibleInsert, FlexibleUpdate } from '@/lib/types/supabase-helpers'\nimport { errorHandler, ErrorCode, AppError } from '@/lib/errors'\nimport { logger } from '@/lib/utils/logger'\n\ntype DocumentSignature = TableRow<'document_signatures'>\ntype DocumentSignatureInsert = TableInsert<'document_signatures'>\ntype DocumentSignatureUpdate = TableUpdate<'document_signatures'>\n\nexport interface CreateSignatureParams {\n  documentId: string\n  organizationId: string\n  signerId: string\n  signatureData: string // Base64 image\n  signatureType?: 'handwritten' | 'typed' | 'image'\n  signerName?: string\n  signerEmail?: string\n  signerRole?: string\n  positionX?: number\n  positionY?: number\n  width?: number\n  height?: number\n  pageNumber?: number\n  comment?: string\n}\n\nexport interface SignatureWithUser {\n  id: string\n  document_id: string\n  signer_id: string\n  signature_data: string\n  signature_type: 'handwritten' | 'typed' | 'image' | null\n  signer_name: string | null\n  signer_email: string | null\n  signer_role: string | null\n  position_x: number | null\n  position_y: number | null\n  width: number | null\n  height: number | null\n  page_number: number | null\n  status: 'pending' | 'signed' | 'declined' | 'revoked' | 'expired' | null\n  is_valid: boolean | null\n  signed_at: string | null\n  comment: string | null\n  created_at: string\n  signer: {\n    id: string\n    full_name: string | null\n    email: string | null\n    role: string | null\n  } | null\n}\n\n/**\n * Service pour gérer les signatures électroniques de documents\n */\nexport class SignatureService {\n  private supabase: SupabaseClient<Database>\n\n\n  constructor(supabaseClient?: SupabaseClient<Database>) {\n\n    this.supabase = supabaseClient || createClient()\n\n  }\n\n  /**\n   * Récupère toutes les signatures d'un document\n   */\n  async getSignaturesByDocument(documentId: string) {\n    try {\n      const { data, error } = await this.supabase\n        .from('document_signatures')\n        .select(`\n          *,\n          signer:users!document_signatures_signer_id_fkey(id, full_name, email, role)\n        `)\n        .eq('document_id', documentId)\n        .eq('status', 'signed')\n        .order('signed_at', { ascending: true })\n\n      if (error) throw error\n      return (data || []) as SignatureWithUser[]\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'getSignaturesByDocument',\n        documentId,\n      })\n    }\n  }\n\n  /**\n   * Récupère une signature par son ID\n   */\n  async getSignatureById(signatureId: string) {\n    try {\n      const { data, error } = await this.supabase\n        .from('document_signatures')\n        .select(`\n          *,\n          signer:users!document_signatures_signer_id_fkey(id, full_name, email, role),\n          document:documents(id, title, organization_id)\n        `)\n        .eq('id', signatureId)\n        .single()\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          throw errorHandler.createNotFoundError(\n            `Signature avec l'ID ${signatureId} introuvable`,\n            { signatureId }\n          )\n        }\n        throw error\n      }\n\n      return data as SignatureWithUser & {\n        document: { id: string; title: string | null; organization_id: string } | null\n      }\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'getSignatureById',\n        signatureId,\n      })\n    }\n  }\n\n  /**\n   * Récupère toutes les signatures d'un utilisateur\n   */\n  async getSignaturesByUser(userId: string, organizationId: string) {\n    try {\n      const { data, error } = await this.supabase\n        .from('document_signatures')\n        .select(`\n          *,\n          document:documents(id, title, type, organization_id)\n        `)\n        .eq('signer_id', userId)\n        .eq('organization_id', organizationId)\n        .order('signed_at', { ascending: false })\n\n      if (error) throw error\n      return data || []\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'getSignaturesByUser',\n        userId,\n        organizationId,\n      })\n    }\n  }\n\n  /**\n   * Récupère toutes les signatures pour les documents liés à une session\n   * (via les étudiants inscrits à la session)\n   */\n  async getSignaturesBySession(sessionId: string, organizationId: string) {\n    try {\n      // Récupérer les étudiants inscrits à la session\n      const { data: enrollments, error: enrollmentsError } = await this.supabase\n        .from('enrollments')\n        .select('student_id')\n        .eq('session_id', sessionId)\n        .in('status', ['confirmed', 'completed', 'active'])\n\n      if (enrollmentsError) throw enrollmentsError\n      if (!enrollments || enrollments.length === 0) return []\n\n      const studentIds = enrollments.map((e: any) => e.student_id).filter(Boolean)\n\n      // Récupérer les documents de ces étudiants\n      const { data: documents, error: documentsError } = await this.supabase\n        .from('documents')\n        .select('id')\n        .eq('organization_id', organizationId)\n        .in('student_id', studentIds)\n\n      if (documentsError) throw documentsError\n      if (!documents || documents.length === 0) return []\n\n      const documentIds = documents.map((d: any) => d.id)\n\n      // Récupérer les signatures de ces documents\n      const { data, error } = await this.supabase\n        .from('document_signatures')\n        .select(`\n          *,\n          signer:users!document_signatures_signer_id_fkey(id, full_name, email, role),\n          document:documents(id, title, type, student_id, students(id, first_name, last_name))\n        `)\n        .in('document_id', documentIds)\n        .eq('organization_id', organizationId)\n        .order('signed_at', { ascending: false })\n\n      if (error) throw error\n      return (data || []) as (SignatureWithUser & {\n        document: {\n          id: string\n          title: string | null\n          type: string | null\n          student_id: string | null\n          students: { id: string; first_name: string | null; last_name: string | null } | null\n        } | null\n      })[]\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'getSignaturesBySession',\n        sessionId,\n        organizationId,\n      })\n    }\n  }\n\n  /**\n   * Crée une nouvelle signature\n   */\n  async createSignature(params: CreateSignatureParams) {\n    try {\n      // Récupérer les informations de l'utilisateur\n      const { data: userData } = await this.supabase.auth.getUser()\n      if (!userData.user) {\n        throw errorHandler.createAuthError(ErrorCode.AUTH_REQUIRED, 'Utilisateur non authentifié')\n      }\n\n      // Générer un code de validation\n      const validationCode = this.generateValidationCode()\n\n      // Récupérer l'IP et le user agent si disponibles\n      let ipAddress: string | null = null\n      let userAgent: string | null = null\n      \n      if (typeof window !== 'undefined') {\n        userAgent = navigator.userAgent\n        // L'IP sera récupérée côté serveur si nécessaire\n      }\n\n      const signatureData: FlexibleInsert<'document_signatures'> = {\n        document_id: params.documentId,\n        organization_id: params.organizationId,\n        signer_id: params.signerId,\n        signature_data: params.signatureData,\n        signature_type: params.signatureType || 'handwritten',\n        signer_name: params.signerName || userData.user.user_metadata?.full_name || 'Utilisateur',\n        signer_email: params.signerEmail || userData.user.email || null,\n        signer_role: params.signerRole || null,\n        position_x: params.positionX || null,\n        position_y: params.positionY || null,\n        width: params.width || 200,\n        height: params.height || 80,\n        page_number: params.pageNumber || 1,\n        status: 'signed',\n        is_valid: true,\n        validation_code: validationCode,\n        comment: params.comment || null,\n        ip_address: ipAddress,\n        user_agent: userAgent,\n      }\n\n      const { data, error } = await this.supabase\n        .from('document_signatures')\n        .insert(signatureData as DocumentSignatureInsert)\n        .select(`\n          *,\n          signer:users!document_signatures_signer_id_fkey(id, full_name, email, role)\n        `)\n        .single()\n\n      if (error) throw error\n\n      logger.info('Signature créée', {\n        signatureId: data.id,\n        documentId: params.documentId,\n        signerId: params.signerId,\n      })\n\n      return data as SignatureWithUser\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'createSignature',\n        documentId: params.documentId,\n        signerId: params.signerId,\n      })\n    }\n  }\n\n  /**\n   * Met à jour une signature\n   */\n  async updateSignature(signatureId: string, updates: FlexibleUpdate<'document_signatures'>) {\n    try {\n      const { data, error } = await this.supabase\n        .from('document_signatures')\n        .update(updates as DocumentSignatureUpdate)\n        .eq('id', signatureId)\n        .select()\n        .single()\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          throw errorHandler.createNotFoundError(\n            `Signature avec l'ID ${signatureId} introuvable`,\n            { signatureId }\n          )\n        }\n        throw error\n      }\n\n      return data\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'updateSignature',\n        signatureId,\n      })\n    }\n  }\n\n  /**\n   * Révoque une signature\n   */\n  async revokeSignature(signatureId: string, reason?: string) {\n    try {\n      return this.updateSignature(signatureId, {\n        status: 'revoked',\n        is_valid: false,\n        comment: reason || 'Signature révoquée',\n      })\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'revokeSignature',\n        signatureId,\n      })\n    }\n  }\n\n  /**\n   * Supprime une signature\n   */\n  async deleteSignature(signatureId: string) {\n    try {\n      const { error } = await this.supabase\n        .from('document_signatures')\n        .delete()\n        .eq('id', signatureId)\n\n      if (error) throw error\n\n      logger.info('Signature supprimée', { signatureId })\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'deleteSignature',\n        signatureId,\n      })\n    }\n  }\n\n  /**\n   * Vérifie si un document a des signatures\n   */\n  async hasSignatures(documentId: string): Promise<boolean> {\n    try {\n      const { count, error } = await this.supabase\n        .from('document_signatures')\n        .select('*', { count: 'exact', head: true })\n        .eq('document_id', documentId)\n        .eq('status', 'signed')\n\n      if (error) throw error\n      return (count || 0) > 0\n    } catch (error) {\n      if (error instanceof AppError) throw error\n      throw errorHandler.handleError(error, {\n        operation: 'hasSignatures',\n        documentId,\n      })\n    }\n  }\n\n  /**\n   * Génère un code de validation pour la signature\n   */\n  private generateValidationCode(): string {\n    const timestamp = Date.now()\n    const random = Math.random().toString(36).substring(2, 15)\n    return `${timestamp}-${random}`\n  }\n\n  /**\n   * Valide l'intégrité d'une signature\n   */\n  async validateSignature(signatureId: string, validationCode: string): Promise<boolean> {\n    try {\n      const signature = await this.getSignatureById(signatureId)\n      const sig = signature as any\n      return (sig.validation_code === validationCode) && (sig.is_valid === true)\n    } catch (error) {\n      return false\n    }\n  }\n}\n\nexport const signatureService = new SignatureService()\n\n","/**\n * Service de traitement des webhooks de signature électronique\n * Gère les événements des différents providers (Yousign, DocuSign, HelloSign, etc.)\n */\n\nimport { signatureService } from '@/lib/services/signature.service'\nimport { logger, maskId } from '@/lib/utils/logger'\nimport { createClient } from '@/lib/supabase/server'\n\nexport type SignatureEventType =\n  | 'signature.created'\n  | 'signature.pending'\n  | 'signature.signed'\n  | 'signature.completed'\n  | 'signature.declined'\n  | 'signature.expired'\n  | 'signature.canceled'\n  | 'document.sent'\n  | 'document.opened'\n  | 'document.downloaded'\n\nexport interface SignatureWebhookEvent {\n  provider: 'yousign' | 'docusign' | 'hellosign' | 'signnow' | 'other'\n  eventType: SignatureEventType\n  signatureId?: string // ID externe du provider\n  documentId?: string // Notre ID interne\n  signerEmail?: string\n  signerName?: string\n  signedAt?: string\n  status?: string\n  metadata?: Record<string, any>\n  rawPayload?: any\n}\n\nexport interface WebhookProcessingResult {\n  success: boolean\n  message: string\n  signatureId?: string\n  documentId?: string\n  action?: string\n}\n\n/**\n * Service de traitement des webhooks de signature électronique\n */\nexport class ESignatureWebhookHandlerService {\n  /**\n   * Traite un événement webhook générique\n   */\n  async processWebhookEvent(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    try {\n      logger.info('Traitement du webhook de signature', {\n        provider: event.provider,\n        eventType: event.eventType,\n        signatureId: maskId(event.signatureId),\n        documentId: maskId(event.documentId),\n      })\n\n      // Router vers le bon handler selon le type d'événement\n      switch (event.eventType) {\n        case 'signature.created':\n        case 'signature.pending':\n          return await this.handleSignaturePending(event)\n\n        case 'signature.signed':\n          return await this.handleSignatureSigned(event)\n\n        case 'signature.completed':\n          return await this.handleSignatureCompleted(event)\n\n        case 'signature.declined':\n          return await this.handleSignatureDeclined(event)\n\n        case 'signature.expired':\n          return await this.handleSignatureExpired(event)\n\n        case 'signature.canceled':\n          return await this.handleSignatureCanceled(event)\n\n        case 'document.sent':\n        case 'document.opened':\n        case 'document.downloaded':\n          return await this.handleDocumentEvent(event)\n\n        default:\n          logger.warn('Type d\\'événement webhook non géré', {\n            eventType: event.eventType,\n            provider: event.provider,\n          })\n          return {\n            success: true,\n            message: `Événement ${event.eventType} enregistré mais non traité`,\n          }\n      }\n    } catch (error) {\n      logger.error('Erreur lors du traitement du webhook', error instanceof Error ? error : new Error(String(error)), {\n        provider: event.provider,\n        eventType: event.eventType,\n        signatureId: maskId(event.signatureId),\n      })\n      throw error\n    }\n  }\n\n  /**\n   * Gère les événements de signature en attente\n   */\n  private async handleSignaturePending(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    // Créer ou mettre à jour la signature avec le statut pending\n    if (event.documentId && event.signerEmail) {\n      const supabase = await createClient()\n\n      // Vérifier si la signature existe déjà\n      const { data: existingSignatures } = await supabase\n        .from('document_signatures')\n        .select('id')\n        .eq('document_id', event.documentId)\n        .eq('signer_email', event.signerEmail)\n        .eq('status', 'pending')\n        .limit(1)\n\n      if (existingSignatures && existingSignatures.length > 0) {\n        return {\n          success: true,\n          message: 'Signature en attente déjà enregistrée',\n          signatureId: existingSignatures[0].id,\n          documentId: event.documentId,\n        }\n      }\n\n      logger.info('Signature en attente créée', {\n        documentId: maskId(event.documentId),\n        signerEmail: event.signerEmail,\n      })\n    }\n\n    return {\n      success: true,\n      message: 'Événement de signature en attente traité',\n      documentId: event.documentId,\n      action: 'pending_recorded',\n    }\n  }\n\n  /**\n   * Gère les événements de signature signée\n   */\n  private async handleSignatureSigned(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    if (!event.documentId) {\n      throw new Error('documentId manquant dans l\\'événement signature.signed')\n    }\n\n    const supabase = await createClient()\n\n    // Trouver la signature correspondante\n    const { data: signatures } = await supabase\n      .from('document_signatures')\n      .select('*')\n      .eq('document_id', event.documentId)\n      .or(`signer_email.eq.${event.signerEmail},validation_code.eq.${event.signatureId}`)\n      .limit(1)\n\n    if (signatures && signatures.length > 0) {\n      const signature = signatures[0]\n\n      // Mettre à jour le statut de la signature\n      await signatureService.updateSignature(signature.id, {\n        status: 'signed',\n        is_valid: true,\n        signed_at: event.signedAt ? new Date(event.signedAt).toISOString() : new Date().toISOString(),\n      })\n\n      logger.info('Signature mise à jour comme signée', {\n        signatureId: maskId(signature.id),\n        documentId: maskId(event.documentId),\n      })\n\n      return {\n        success: true,\n        message: 'Signature enregistrée comme signée',\n        signatureId: signature.id,\n        documentId: event.documentId,\n        action: 'signature_signed',\n      }\n    }\n\n    logger.warn('Aucune signature correspondante trouvée pour l\\'événement signed', {\n      documentId: maskId(event.documentId),\n      signerEmail: event.signerEmail,\n    })\n\n    return {\n      success: true,\n      message: 'Événement enregistré mais aucune signature correspondante',\n      documentId: event.documentId,\n    }\n  }\n\n  /**\n   * Gère les événements de signature complétée (toutes les signatures du document)\n   */\n  private async handleSignatureCompleted(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    if (!event.documentId) {\n      throw new Error('documentId manquant dans l\\'événement signature.completed')\n    }\n\n    const supabase = await createClient()\n\n    // Mettre à jour le statut du document\n    const { error: updateError } = await supabase\n      .from('documents')\n      .update({\n        status: 'signed',\n        signed_at: new Date().toISOString(),\n      } as any)\n      .eq('id', event.documentId)\n\n    if (updateError) {\n      logger.error('Erreur lors de la mise à jour du document', updateError, {\n        documentId: maskId(event.documentId),\n      })\n    }\n\n    // Marquer toutes les signatures du document comme complétées\n    const { error: signaturesError } = await supabase\n      .from('document_signatures')\n      .update({ status: 'signed' })\n      .eq('document_id', event.documentId)\n      .in('status', ['pending', 'processing'])\n\n    if (signaturesError) {\n      logger.error('Erreur lors de la mise à jour des signatures', signaturesError, {\n        documentId: maskId(event.documentId),\n      })\n    }\n\n    logger.info('Document marqué comme complètement signé', {\n      documentId: maskId(event.documentId),\n    })\n\n    // TODO: Générer le document final avec toutes les signatures\n    // TODO: Envoyer une notification aux parties concernées\n\n    return {\n      success: true,\n      message: 'Document complètement signé',\n      documentId: event.documentId,\n      action: 'document_completed',\n    }\n  }\n\n  /**\n   * Gère les événements de signature refusée\n   */\n  private async handleSignatureDeclined(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    if (!event.documentId) {\n      throw new Error('documentId manquant dans l\\'événement signature.declined')\n    }\n\n    const supabase = await createClient()\n\n    // Trouver et mettre à jour la signature\n    const { data: signatures } = await supabase\n      .from('document_signatures')\n      .select('id')\n      .eq('document_id', event.documentId)\n      .eq('signer_email', event.signerEmail || '')\n      .limit(1)\n\n    if (signatures && signatures.length > 0) {\n      await signatureService.revokeSignature(\n        signatures[0].id,\n        'Signature refusée par le signataire'\n      )\n\n      logger.info('Signature marquée comme refusée', {\n        signatureId: maskId(signatures[0].id),\n        documentId: maskId(event.documentId),\n      })\n\n      return {\n        success: true,\n        message: 'Signature refusée enregistrée',\n        signatureId: signatures[0].id,\n        documentId: event.documentId,\n        action: 'signature_declined',\n      }\n    }\n\n    return {\n      success: true,\n      message: 'Événement de refus enregistré',\n      documentId: event.documentId,\n    }\n  }\n\n  /**\n   * Gère les événements de signature expirée\n   */\n  private async handleSignatureExpired(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    if (!event.documentId) {\n      throw new Error('documentId manquant dans l\\'événement signature.expired')\n    }\n\n    const supabase = await createClient()\n\n    // Mettre à jour toutes les signatures pendantes comme expirées\n    const { error } = await supabase\n      .from('document_signatures')\n      .update({\n        status: 'expired',\n        is_valid: false,\n      })\n      .eq('document_id', event.documentId)\n      .eq('status', 'pending')\n\n    if (error) {\n      logger.error('Erreur lors de la mise à jour des signatures expirées', error, {\n        documentId: maskId(event.documentId),\n      })\n    }\n\n    logger.info('Signatures marquées comme expirées', {\n      documentId: maskId(event.documentId),\n    })\n\n    return {\n      success: true,\n      message: 'Signatures expirées',\n      documentId: event.documentId,\n      action: 'signatures_expired',\n    }\n  }\n\n  /**\n   * Gère les événements de signature annulée\n   */\n  private async handleSignatureCanceled(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    if (!event.documentId) {\n      throw new Error('documentId manquant dans l\\'événement signature.canceled')\n    }\n\n    const supabase = await createClient()\n\n    // Révoquer toutes les signatures du document\n    const { data: signatures } = await supabase\n      .from('document_signatures')\n      .select('id')\n      .eq('document_id', event.documentId)\n      .in('status', ['pending', 'processing'])\n\n    if (signatures) {\n      for (const sig of signatures) {\n        await signatureService.revokeSignature(sig.id, 'Procédure de signature annulée')\n      }\n    }\n\n    logger.info('Procédure de signature annulée', {\n      documentId: maskId(event.documentId),\n      signaturesCount: signatures?.length || 0,\n    })\n\n    return {\n      success: true,\n      message: 'Procédure de signature annulée',\n      documentId: event.documentId,\n      action: 'signature_canceled',\n    }\n  }\n\n  /**\n   * Gère les événements liés au document (envoi, ouverture, téléchargement)\n   */\n  private async handleDocumentEvent(event: SignatureWebhookEvent): Promise<WebhookProcessingResult> {\n    // Ces événements sont surtout informatifs pour le tracking\n    logger.info('Événement document reçu', {\n      eventType: event.eventType,\n      documentId: maskId(event.documentId),\n      signerEmail: event.signerEmail,\n    })\n\n    // TODO: Enregistrer dans un audit log si nécessaire\n\n    return {\n      success: true,\n      message: `Événement ${event.eventType} enregistré`,\n      documentId: event.documentId,\n      action: 'document_event_logged',\n    }\n  }\n\n  /**\n   * Parse le payload d'un webhook Yousign\n   */\n  parseYousignWebhook(payload: any): SignatureWebhookEvent {\n    const eventType = this.mapYousignEventType(payload.event_name || payload.type)\n\n    return {\n      provider: 'yousign',\n      eventType,\n      signatureId: payload.signature_request?.id || payload.id,\n      documentId: payload.metadata?.documentId || payload.signature_request?.metadata?.documentId,\n      signerEmail: payload.signer?.email || payload.signature_request?.signer?.email,\n      signerName: payload.signer?.info?.first_name && payload.signer?.info?.last_name\n        ? `${payload.signer.info.first_name} ${payload.signer.info.last_name}`\n        : undefined,\n      signedAt: payload.signer?.signed_at || payload.signature_request?.signed_at,\n      status: payload.status || payload.signature_request?.status,\n      metadata: payload.metadata,\n      rawPayload: payload,\n    }\n  }\n\n  /**\n   * Parse le payload d'un webhook DocuSign\n   */\n  parseDocuSignWebhook(payload: any): SignatureWebhookEvent {\n    const eventType = this.mapDocuSignEventType(payload.event)\n\n    return {\n      provider: 'docusign',\n      eventType,\n      signatureId: payload.envelopeId || payload.data?.envelopeId,\n      documentId: payload.envelopeSummary?.customFields?.textCustomFields?.find(\n        (f: any) => f.name === 'documentId'\n      )?.value,\n      signerEmail: payload.data?.recipients?.signers?.[0]?.email,\n      signerName: payload.data?.recipients?.signers?.[0]?.name,\n      signedAt: payload.data?.recipients?.signers?.[0]?.signedDateTime,\n      status: payload.data?.envelopeStatus || payload.status,\n      metadata: payload.data,\n      rawPayload: payload,\n    }\n  }\n\n  /**\n   * Parse le payload d'un webhook HelloSign\n   */\n  parseHelloSignWebhook(payload: any): SignatureWebhookEvent {\n    const eventType = this.mapHelloSignEventType(payload.event?.event_type)\n\n    return {\n      provider: 'hellosign',\n      eventType,\n      signatureId: payload.signature_request?.signature_request_id,\n      documentId: payload.signature_request?.metadata?.documentId,\n      signerEmail: payload.event?.event_metadata?.reported_for_signer_email,\n      signerName: payload.signature_request?.signatures?.[0]?.signer_name,\n      signedAt: payload.signature_request?.signatures?.[0]?.signed_at\n        ? new Date(payload.signature_request.signatures[0].signed_at * 1000).toISOString()\n        : undefined,\n      status: payload.signature_request?.status,\n      metadata: payload.signature_request?.metadata,\n      rawPayload: payload,\n    }\n  }\n\n  /**\n   * Mappe les types d'événements Yousign vers notre format\n   */\n  private mapYousignEventType(yousignEvent: string): SignatureEventType {\n    const mapping: Record<string, SignatureEventType> = {\n      'signature_request.created': 'signature.created',\n      'signature_request.activated': 'signature.pending',\n      'signature_request.signed': 'signature.signed',\n      'signature_request.done': 'signature.completed',\n      'signature_request.refused': 'signature.declined',\n      'signature_request.expired': 'signature.expired',\n      'signature_request.canceled': 'signature.canceled',\n    }\n\n    return mapping[yousignEvent] || 'signature.created'\n  }\n\n  /**\n   * Mappe les types d'événements DocuSign vers notre format\n   */\n  private mapDocuSignEventType(docusignEvent: string): SignatureEventType {\n    const mapping: Record<string, SignatureEventType> = {\n      'envelope-created': 'signature.created',\n      'envelope-sent': 'document.sent',\n      'envelope-delivered': 'document.opened',\n      'recipient-completed': 'signature.signed',\n      'envelope-completed': 'signature.completed',\n      'recipient-declined': 'signature.declined',\n      'envelope-voided': 'signature.canceled',\n    }\n\n    return mapping[docusignEvent] || 'signature.created'\n  }\n\n  /**\n   * Mappe les types d'événements HelloSign vers notre format\n   */\n  private mapHelloSignEventType(hellosignEvent: string): SignatureEventType {\n    const mapping: Record<string, SignatureEventType> = {\n      'signature_request_sent': 'document.sent',\n      'signature_request_viewed': 'document.opened',\n      'signature_request_signed': 'signature.signed',\n      'signature_request_all_signed': 'signature.completed',\n      'signature_request_declined': 'signature.declined',\n      'signature_request_canceled': 'signature.canceled',\n      'signature_request_expired': 'signature.expired',\n    }\n\n    return mapping[hellosignEvent] || 'signature.created'\n  }\n}\n\nexport const webhookHandlerService = new ESignatureWebhookHandlerService()\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServer"],"mappings":"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","ignoreList":[0,1]}
{"version":3,"sources":["../../../lib/utils/document-generation/loop-processor.ts","../../../lib/utils/document-generation/attachment-processor.ts","../../../lib/utils/document-generation/calculated-variables.ts","../../../lib/utils/document-generation/dynamic-hyperlinks-processor.ts","../../../lib/utils/document-generation/element-visibility-processor.ts","../../../lib/utils/document-generation/nested-variables-processor.ts","../../../lib/utils/document-generation/dynamic-table-processor.ts","../../../lib/utils/document-generation/conditional-processor.ts","../../../lib/utils/document-generation/form-field-processor.ts","../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../lib/utils/document-generation/signature-processor.ts"],"sourcesContent":["/**\n * Traitement des boucles dans les templates\n */\n\n/**\n * Traite les boucles FOR/WHILE dans le contenu HTML\n */\nexport function processLoops(\n  html: string,\n  variables: Record<string, any>\n): string {\n  // Pour l'instant, retourner le HTML tel quel\n  // Les boucles peuvent être implémentées plus tard si nécessaire\n  return html\n}\n","/**\n * Traitement des pièces jointes dans les templates\n */\n\n/**\n * Traite les pièces jointes dans le contenu HTML\n */\nexport async function processAttachments(\n  html: string,\n  variables: Record<string, any> = {},\n  documentId?: string\n): Promise<string> {\n  // Pour l'instant, retourner le HTML tel quel\n  // Le traitement des pièces jointes peut être implémenté plus tard si nécessaire\n  return html\n}\n","/**\n * Traitement des variables calculées dans les templates\n */\n\n/**\n * Traite les variables calculées (formules, expressions) dans le contenu HTML\n */\nexport function processCalculatedVariables(\n  html: string,\n  variables: Record<string, any>\n): string {\n  // Pour l'instant, retourner le HTML tel quel\n  // Les variables calculées peuvent être implémentées plus tard si nécessaire\n  return html\n}\n","/**\n * Traitement des hyperliens dynamiques dans les templates\n */\n\n/**\n * Traite les hyperliens dynamiques dans le contenu HTML\n */\nexport function processDynamicHyperlinks(\n  html: string,\n  variables: Record<string, any>\n): string {\n  // Pour l'instant, retourner le HTML tel quel\n  // Les hyperliens dynamiques peuvent être implémentés plus tard si nécessaire\n  return html\n}\n","/**\n * Traitement de la visibilité des éléments dans les templates\n */\n\n/**\n * Traite la visibilité conditionnelle des éléments dans le contenu HTML\n */\nexport function processElementVisibility(\n  html: string,\n  variables: Record<string, any>\n): string {\n  // Pour l'instant, retourner le HTML tel quel\n  // La visibilité conditionnelle peut être implémentée plus tard si nécessaire\n  return html\n}\n","/**\n * Traitement des variables imbriquées dans les templates\n */\n\nimport type { DocumentVariables } from '@/lib/types/document-templates'\n\n/**\n * Aplatit les variables imbriquées en une structure plate\n * Par exemple : { user: { name: 'John' } } devient { 'user.name': 'John' }\n */\nexport function flattenVariables(variables: DocumentVariables): Record<string, any> {\n  const flattened: Record<string, any> = {}\n  \n  function flatten(obj: any, prefix = ''): void {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const newKey = prefix ? `${prefix}.${key}` : key\n        const value = obj[key]\n        \n        if (value !== null && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\n          // Récursivement aplatir les objets imbriqués\n          flatten(value, newKey)\n        } else {\n          // Ajouter la valeur aplatie\n          flattened[newKey] = value\n        }\n      }\n    }\n  }\n  \n  flatten(variables)\n  return flattened\n}\n\n/**\n * Traite les variables imbriquées dans le contenu HTML\n * Remplace les références comme {user.name} par leurs valeurs\n */\nexport function processNestedVariables(\n  html: string,\n  variables: Record<string, any>\n): string {\n  let result = html\n  \n  // Remplacer les variables imbriquées au format {object.property}\n  for (const key in variables) {\n    if (variables.hasOwnProperty(key)) {\n      const value = variables[key]\n      if (value !== null && value !== undefined) {\n        // Remplacer {object.property} ou {object_property}\n        const regex = new RegExp(`\\\\{${key.replace(/\\./g, '\\\\.')}\\\\}`, 'g')\n        result = result.replace(regex, String(value))\n      }\n    }\n  }\n  \n  return result\n}\n","/**\n * Traitement des tableaux dynamiques dans les templates\n * Permet de générer des tableaux à partir de données structurées\n */\n\n/**\n * Traite les tableaux dynamiques dans le contenu HTML\n * Remplace les patterns de tableaux dynamiques par du HTML généré\n */\nexport function processDynamicTables(\n  html: string,\n  variables: Record<string, any>\n): string {\n  let result = html\n\n  // Pattern pour les tableaux dynamiques : {{#table variable_name}}\n  // Exemple : {{#table facture_items}}\n  const tablePattern = /\\{\\{#table\\s+(\\w+)\\}\\}([\\s\\S]*?)\\{\\{\\/table\\}\\}/g\n\n  result = result.replace(tablePattern, (match, variableName, tableTemplate) => {\n    const tableData = variables[variableName]\n\n    // Si la variable n'existe pas ou n'est pas un tableau, retourner le template vide\n    if (!tableData || !Array.isArray(tableData)) {\n      return ''\n    }\n\n    // Si c'est une chaîne JSON, parser\n    let items: any[] = []\n    if (typeof tableData === 'string') {\n      try {\n        items = JSON.parse(tableData)\n      } catch {\n        return ''\n      }\n    } else {\n      items = tableData\n    }\n\n    // Générer les lignes du tableau\n    const rows = items.map((item, index) => {\n      let row = tableTemplate\n\n      // Remplacer les variables dans le template de ligne\n      // Support pour {variable} et {item.variable}\n      Object.keys(item).forEach((key) => {\n        const value = item[key] !== null && item[key] !== undefined ? String(item[key]) : ''\n        const regex = new RegExp(`\\\\{${key}\\\\}`, 'g')\n        row = row.replace(regex, value)\n        // Support pour {item.variable}\n        const itemRegex = new RegExp(`\\\\{item\\\\.${key}\\\\}`, 'g')\n        row = row.replace(itemRegex, value)\n      })\n\n      // Variables spéciales\n      row = row.replace(/\\{index\\}/g, String(index + 1))\n      row = row.replace(/\\{row_number\\}/g, String(index + 1))\n\n      return row\n    }).join('')\n\n    return rows\n  })\n\n  // Pattern pour les tableaux simples avec boucle inline\n  // Exemple : {{#each facture_items}}<tr><td>{description}</td></tr>{{/each}}\n  const eachPattern = /\\{\\{#each\\s+(\\w+)\\}\\}([\\s\\S]*?)\\{\\{\\/each\\}\\}/g\n\n  result = result.replace(eachPattern, (match, variableName, itemTemplate) => {\n    const arrayData = variables[variableName]\n\n    if (!arrayData || !Array.isArray(arrayData)) {\n      return ''\n    }\n\n    let items: any[] = []\n    if (typeof arrayData === 'string') {\n      try {\n        items = JSON.parse(arrayData)\n      } catch {\n        return ''\n      }\n    } else {\n      items = arrayData\n    }\n\n    const rows = items.map((item, index) => {\n      let row = itemTemplate\n\n      // Remplacer les variables dans le template\n      if (typeof item === 'object' && item !== null) {\n        Object.keys(item).forEach((key) => {\n          const value = item[key] !== null && item[key] !== undefined ? String(item[key]) : ''\n          const regex = new RegExp(`\\\\{${key}\\\\}`, 'g')\n          row = row.replace(regex, value)\n        })\n      } else {\n        // Si l'item est une valeur simple, remplacer {this} ou {.}\n        row = row.replace(/\\{this\\}/g, String(item))\n        row = row.replace(/\\{\\.\\}/g, String(item))\n      }\n\n      row = row.replace(/\\{index\\}/g, String(index))\n      row = row.replace(/\\{@index\\}/g, String(index))\n\n      return row\n    }).join('')\n\n    return rows\n  })\n\n  return result\n}\n","/**\n * Traite les conditions conditionnelles dans le HTML\n * Supporte les syntaxes : {IF variable}...{ENDIF}, {IF variable}...{ELSE}...{ENDIF}\n */\n\nexport interface DocumentVariables {\n  [key: string]: any\n}\n\n/**\n * Traite les conditions IF/ELSE/ENDIF dans le HTML\n * Supporte aussi la syntaxe JSX : {variable && ...}\n */\nexport function processConditionals(html: string, variables: DocumentVariables): string {\n  if (!html) return html\n\n  let result = html\n\n  // 1. Traiter la syntaxe JSX : {variable && <tag>...</tag>}\n  // Utiliser un parser qui gère correctement les balises HTML imbriquées\n  const processJSXConditionals = (text: string): string => {\n    let processed = text\n    let changed = true\n    let iterations = 0\n    const maxIterations = 10\n    \n    while (changed && iterations < maxIterations) {\n      changed = false\n      iterations++\n      \n      // Trouver toutes les occurrences de {variable && ...\n      const pattern = /\\{([a-zA-Z_][a-zA-Z0-9_]*)\\s+&&\\s+/g\n      let match\n      const replacements: Array<{ start: number; end: number; replacement: string }> = []\n      \n      // Trouver toutes les correspondances et les traiter de droite à gauche\n      const matches: Array<{ varName: string; start: number; varEnd: number }> = []\n      while ((match = pattern.exec(processed)) !== null) {\n        matches.push({\n          varName: match[1].trim(),\n          start: match.index,\n          varEnd: match.index + match[0].length,\n        })\n      }\n      \n      // Traiter de droite à gauche pour préserver les indices\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const m = matches[i]\n        let depth = 1 // On est déjà dans une accolade ouvrante\n        let pos = m.varEnd\n        let inString = false\n        let stringChar = ''\n        let foundEnd = false\n        let endPos = -1\n        \n        // Chercher la fin de la conditionnelle en gérant les accolades imbriquées et les strings\n        while (pos < processed.length && !foundEnd) {\n          const char = processed[pos]\n          \n          if (!inString) {\n            if (char === '\"' || char === \"'\") {\n              inString = true\n              stringChar = char\n            } else if (char === '{') {\n              depth++\n            } else if (char === '}') {\n              depth--\n              if (depth === 0) {\n                foundEnd = true\n                endPos = pos\n              }\n            }\n          } else {\n            if (char === stringChar && processed[pos - 1] !== '\\\\') {\n              inString = false\n            }\n          }\n          \n          pos++\n        }\n        \n        if (foundEnd && endPos > m.start) {\n          const varName = m.varName\n          const content = processed.substring(m.varEnd, endPos)\n          const value = variables[varName]\n          const conditionValue = Boolean(value) && value !== '' && value !== 0 && value !== '0' && value !== null && value !== undefined\n          \n          if (conditionValue) {\n            replacements.push({\n              start: m.start,\n              end: endPos + 1,\n              replacement: content,\n            })\n            changed = true\n          } else {\n            replacements.push({\n              start: m.start,\n              end: endPos + 1,\n              replacement: '',\n            })\n            changed = true\n          }\n        }\n      }\n      \n      // Appliquer les remplacements de droite à gauche\n      for (const rep of replacements) {\n        processed = processed.substring(0, rep.start) + rep.replacement + processed.substring(rep.end)\n      }\n    }\n    \n    return processed\n  }\n\n  result = processJSXConditionals(result)\n\n  // 2. Traiter aussi les conditionnels avec plusieurs variables : {var1 && var2 && ...}\n  const processMultiConditionals = (text: string): string => {\n    let processed = text\n    let changed = true\n    let iterations = 0\n    const maxIterations = 10\n    \n    while (changed && iterations < maxIterations) {\n      changed = false\n      iterations++\n      \n      const pattern = /\\{([a-zA-Z_][a-zA-Z0-9_]*)\\s+&&\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+&&\\s+([^}]+)\\}/g\n      \n      processed = processed.replace(pattern, (match, var1, var2, content) => {\n        const val1 = variables[var1.trim()]\n        const val2 = variables[var2.trim()]\n        const conditionValue = Boolean(val1) && val1 !== '' && Boolean(val2) && val2 !== ''\n        \n        if (conditionValue) {\n          changed = true\n          return content\n        }\n        return ''\n      })\n    }\n    \n    return processed\n  }\n\n  result = processMultiConditionals(result)\n\n  // 3. Traiter la syntaxe IF/ELSE/ENDIF classique\n  const conditionalPattern = /\\{IF\\s+([^}]+)\\}([\\s\\S]*?)(?:\\{ELSE\\}([\\s\\S]*?))?\\{ENDIF\\}/gi\n\n  result = result.replace(conditionalPattern, (match, condition, ifContent, elseContent = '') => {\n    // Évaluer la condition\n    const conditionValue = evaluateCondition(condition.trim(), variables)\n    \n    // Retourner le contenu approprié\n    return conditionValue ? ifContent : elseContent\n  })\n\n  return result\n}\n\n/**\n * Alias pour processConditionals (utilisé par html-generator)\n */\nexport const evaluateConditionalContent = processConditionals\n\n// Export par défaut pour compatibilité\nexport default processConditionals\n\n/**\n * Évalue une condition\n */\nfunction evaluateCondition(condition: string, variables: DocumentVariables): boolean {\n  // Supprimer les espaces\n  condition = condition.trim()\n\n  // Vérifier si c'est une variable simple\n  if (variables.hasOwnProperty(condition)) {\n    const value = variables[condition]\n    // Considérer comme vrai si la valeur existe et n'est pas vide/false/0\n    return Boolean(value) && value !== '' && value !== 0 && value !== '0'\n  }\n\n  // Vérifier les opérateurs de comparaison\n  const operators = ['==', '!=', '>', '<', '>=', '<=']\n  \n  for (const op of operators) {\n    if (condition.includes(op)) {\n      const [left, right] = condition.split(op).map(s => s.trim())\n      const leftValue = getVariableValue(left, variables)\n      const rightValue = getVariableValue(right, variables)\n      \n      switch (op) {\n        case '==':\n          return leftValue == rightValue\n        case '!=':\n          return leftValue != rightValue\n        case '>':\n          return Number(leftValue) > Number(rightValue)\n        case '<':\n          return Number(leftValue) < Number(rightValue)\n        case '>=':\n          return Number(leftValue) >= Number(rightValue)\n        case '<=':\n          return Number(leftValue) <= Number(rightValue)\n        default:\n          return false\n      }\n    }\n  }\n\n  // Par défaut, retourner false\n  return false\n}\n\n/**\n * Récupère la valeur d'une variable ou retourne la valeur littérale\n */\nfunction getVariableValue(expression: string, variables: DocumentVariables): any {\n  expression = expression.trim()\n  \n  // Si c'est une chaîne entre guillemets, retourner la valeur sans guillemets\n  if ((expression.startsWith('\"') && expression.endsWith('\"')) ||\n      (expression.startsWith(\"'\") && expression.endsWith(\"'\"))) {\n    return expression.slice(1, -1)\n  }\n  \n  // Si c'est un nombre, retourner le nombre\n  if (!isNaN(Number(expression))) {\n    return Number(expression)\n  }\n  \n  // Sinon, chercher dans les variables\n  return variables[expression] ?? expression\n}\n","/**\n * Processeur pour les champs de formulaire interactifs\n * Rend les champs de formulaire fonctionnels dans les documents générés\n */\n\n/**\n * Traite les champs de formulaire dans le HTML et les rend interactifs\n */\nexport function processFormFields(html: string, variables: Record<string, any> = {}): string {\n  // Remplacer les variables dans les attributs data-* des champs\n  let processedHTML = html\n\n  // Remplacer les variables dans les valeurs par défaut\n  processedHTML = processedHTML.replace(\n    /value=\"\\{([^}]+)\\}\"/g,\n    (match, varName) => {\n      const value = variables[varName.trim()] || ''\n      return `value=\"${value}\"`\n    }\n  )\n\n  // Remplacer les variables dans les placeholders\n  processedHTML = processedHTML.replace(\n    /placeholder=\"\\{([^}]+)\\}\"/g,\n    (match, varName) => {\n      const value = variables[varName.trim()] || ''\n      return `placeholder=\"${value}\"`\n    }\n  )\n\n  // Remplacer les variables dans les labels\n  processedHTML = processedHTML.replace(\n    />\\{([^}]+)\\}<\\/label>/g,\n    (match, varName) => {\n      const value = variables[varName.trim()] || varName\n      return `>${value}</label>`\n    }\n  )\n\n  // Ajouter le script pour les calculs automatiques\n  if (processedHTML.includes('data-calculation-formula')) {\n    processedHTML += `\n      <script>\n        (function() {\n          // Fonction pour évaluer les formules de calcul\n          function evaluateFormula(formula, fieldValues) {\n            try {\n              // Remplacer les noms de champs par leurs valeurs\n              let expression = formula\n              Object.keys(fieldValues).forEach(fieldName => {\n                const regex = new RegExp('\\\\\\\\b' + fieldName + '\\\\\\\\b', 'g')\n                expression = expression.replace(regex, fieldValues[fieldName] || 0)\n              })\n              \n              // Évaluer l'expression (attention à la sécurité en production)\n              return Function('\"use strict\"; return (' + expression + ')')()\n            } catch (error) {\n              console.error('Erreur lors de l\\'évaluation de la formule:', error)\n              return 0\n            }\n          }\n\n          // Fonction pour mettre à jour les calculs\n          function updateCalculations() {\n            const calculatedFields = document.querySelectorAll('[data-calculation-formula]')\n            const fieldValues = {}\n            \n            // Collecter toutes les valeurs de champs\n            document.querySelectorAll('.form-field-interactive').forEach(field => {\n              const fieldName = field.getAttribute('data-field-name')\n              if (fieldName) {\n                if (field.type === 'checkbox' || field.type === 'radio') {\n                  fieldValues[fieldName] = field.checked ? parseFloat(field.value) || 1 : 0\n                } else {\n                  fieldValues[fieldName] = parseFloat(field.value) || 0\n                }\n              }\n            })\n\n            // Mettre à jour les champs calculés\n            calculatedFields.forEach(field => {\n              const formula = field.getAttribute('data-calculation-formula')\n              const targetField = field.getAttribute('data-calculation-target')\n              \n              if (formula) {\n                const result = evaluateFormula(formula, fieldValues)\n                \n                if (targetField) {\n                  const target = document.querySelector('[name=\"' + targetField + '\"]')\n                  if (target) {\n                    target.value = result\n                  }\n                } else {\n                  field.value = result\n                }\n              }\n            })\n          }\n\n          // Ajouter les écouteurs d'événements\n          document.addEventListener('DOMContentLoaded', function() {\n            document.querySelectorAll('.form-field-interactive').forEach(field => {\n              field.addEventListener('input', updateCalculations)\n              field.addEventListener('change', updateCalculations)\n            })\n            \n            // Mettre à jour les calculs au chargement\n            updateCalculations()\n          })\n        })()\n      </script>\n    `\n  }\n\n  // Ajouter la validation des champs\n  if (processedHTML.includes('form-field-interactive')) {\n    processedHTML += `\n      <script>\n        (function() {\n          function validateField(field) {\n            const validationMessage = field.parentElement.querySelector('.validation-message')\n            let isValid = true\n            let message = ''\n\n            // Validation requise\n            if (field.hasAttribute('required') && !field.value.trim()) {\n              isValid = false\n              message = 'Ce champ est obligatoire'\n            }\n\n            // Validation minlength\n            if (field.hasAttribute('minlength')) {\n              const min = parseInt(field.getAttribute('minlength'))\n              if (field.value.length < min) {\n                isValid = false\n                message = 'Minimum ' + min + ' caractères requis'\n              }\n            }\n\n            // Validation maxlength\n            if (field.hasAttribute('maxlength')) {\n              const max = parseInt(field.getAttribute('maxlength'))\n              if (field.value.length > max) {\n                isValid = false\n                message = 'Maximum ' + max + ' caractères autorisés'\n              }\n            }\n\n            // Validation pattern\n            if (field.hasAttribute('pattern')) {\n              const pattern = new RegExp(field.getAttribute('pattern'))\n              if (!pattern.test(field.value)) {\n                isValid = false\n                message = field.getAttribute('data-validation-message') || 'Format invalide'\n              }\n            }\n\n            // Validation min/max pour les nombres\n            if (field.type === 'number') {\n              if (field.hasAttribute('min')) {\n                const min = parseFloat(field.getAttribute('min'))\n                if (parseFloat(field.value) < min) {\n                  isValid = false\n                  message = 'La valeur minimale est ' + min\n                }\n              }\n              if (field.hasAttribute('max')) {\n                const max = parseFloat(field.getAttribute('max'))\n                if (parseFloat(field.value) > max) {\n                  isValid = false\n                  message = 'La valeur maximale est ' + max\n                }\n              }\n            }\n\n            // Afficher/masquer le message d'erreur\n            if (validationMessage) {\n              if (isValid) {\n                validationMessage.style.display = 'none'\n                field.style.borderColor = '#d1d5db'\n              } else {\n                validationMessage.style.display = 'block'\n                validationMessage.textContent = message\n                field.style.borderColor = '#ef4444'\n              }\n            }\n\n            return isValid\n          }\n\n          document.addEventListener('DOMContentLoaded', function() {\n            document.querySelectorAll('.form-field-interactive').forEach(field => {\n              field.addEventListener('blur', function() {\n                validateField(this)\n              })\n              \n              field.addEventListener('input', function() {\n                const validationMessage = this.parentElement.querySelector('.validation-message')\n                if (validationMessage) {\n                  validationMessage.style.display = 'none'\n                  this.style.borderColor = '#d1d5db'\n                }\n              })\n            })\n          })\n        })()\n      </script>\n    `\n  }\n\n  return processedHTML\n}\n\n/**\n * Extrait les valeurs des champs de formulaire depuis le HTML\n * Note: Cette fonction doit être utilisée uniquement côté client (navigateur)\n */\nexport function extractFormFieldValues(html: string): Record<string, any> {\n  if (typeof window === 'undefined') {\n    // Côté serveur, retourner un objet vide\n    return {}\n  }\n\n  const values: Record<string, any> = {}\n  const parser = new DOMParser()\n  const doc = parser.parseFromString(html, 'text/html')\n  \n  doc.querySelectorAll('.form-field-interactive').forEach((field: any) => {\n    const fieldName = field.getAttribute('name') || field.getAttribute('data-field-name')\n    if (fieldName) {\n      if (field.type === 'checkbox') {\n        values[fieldName] = field.checked\n      } else if (field.type === 'radio') {\n        if (field.checked) {\n          values[fieldName] = field.value\n        }\n      } else {\n        values[fieldName] = field.value\n      }\n    }\n  })\n  \n  return values\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","/**\n * Traitement des signatures dans les templates\n * \n * Ce fichier doit être utilisé uniquement côté serveur (API routes)\n */\n\n'use server'\n\nimport { logger } from '@/lib/utils/logger'\n\n// Import conditionnel pour éviter les erreurs côté serveur\n// Le signatureService utilise createClient() côté client, donc on l'importe dynamiquement\nlet signatureService: any = null\nasync function getSignatureService() {\n  if (typeof window !== 'undefined') {\n    // Côté client\n    if (!signatureService) {\n      const module = await import('@/lib/services/signature.service')\n      signatureService = module.signatureService\n    }\n    return signatureService\n  } else {\n    // Côté serveur - utiliser le client serveur directement\n    // Import dynamique pour éviter que Next.js bundler essaie de bundler next/headers côté client\n    try {\n      const { createClient } = await import('@/lib/supabase/server')\n      const supabase = await createClient()\n      return {\n        getSignaturesByDocument: async (documentId: string) => {\n          const { data, error } = await supabase\n            .from('document_signatures')\n            .select(`\n              *,\n              signer:users!document_signatures_signer_id_fkey(id, full_name, email, role)\n            `)\n            .eq('document_id', documentId)\n            .eq('status', 'signed')\n            .order('signed_at', { ascending: true })\n          if (error) throw error\n          return data || []\n        },\n      }\n    } catch (error) {\n      // Si l'import échoue (par exemple côté client), retourner un service vide\n      console.warn('Impossible d\\'importer createClient côté serveur:', error)\n      return {\n        getSignaturesByDocument: async () => [],\n      }\n    }\n  }\n}\n\n/**\n * Interface pour une zone de signature dans un document\n */\nexport interface SignatureField {\n  id: string\n  type: 'signature' | 'initials' | 'date' | 'text'\n  label?: string\n  required?: boolean\n  signerRole?: string\n  signerEmail?: string\n  width?: number\n  height?: number\n  page?: number\n}\n\n/**\n * Traite les zones de signature dans le contenu HTML\n * Recherche les balises <signature-field> et les remplace par:\n * - Les signatures réelles si disponibles (documentId fourni)\n * - Des zones vides à remplir si pas encore signées\n *\n * Format supporté:\n * <signature-field\n *   id=\"unique-id\"\n *   type=\"signature|initials|date|text\"\n *   label=\"Signature du formateur\"\n *   required=\"true|false\"\n *   signer-role=\"trainer|student|admin\"\n *   signer-email=\"email@example.com\"\n *   width=\"200\"\n *   height=\"80\"\n *   page=\"1\"\n * />\n */\nexport async function processSignatures(\n  html: string,\n  variables: Record<string, any> = {},\n  documentId?: string\n): Promise<string> {\n  try {\n    // Regex pour trouver toutes les balises signature-field\n    const signatureFieldRegex = /<signature-field\\s+([^>]*?)\\/>/gi\n\n    // Extraire toutes les balises\n    const matches = Array.from(html.matchAll(signatureFieldRegex))\n\n    if (matches.length === 0) {\n      return html\n    }\n\n    // Charger les signatures existantes si documentId est fourni\n    let existingSignatures: any[] = []\n    if (documentId) {\n      try {\n        const service = await getSignatureService()\n        existingSignatures = await service.getSignaturesByDocument(documentId)\n      } catch (error) {\n        logger.warn('Erreur lors du chargement des signatures', {\n          documentId,\n          error: error instanceof Error ? error.message : String(error),\n        })\n      }\n    }\n\n    // Traiter chaque balise\n    let processedHtml = html\n    for (const match of matches) {\n      const fullTag = match[0]\n      const attributes = match[1]\n\n      // Parser les attributs\n      const field = parseSignatureFieldAttributes(attributes)\n\n      // Chercher une signature correspondante\n      const existingSignature = existingSignatures.find(sig => {\n        // Correspondance par rôle ou email\n        if (field.signerRole && sig.signer_role === field.signerRole) return true\n        if (field.signerEmail && sig.signer_email === field.signerEmail) return true\n        return false\n      })\n\n      // Générer le HTML de remplacement\n      const replacementHtml = existingSignature\n        ? generateSignedFieldHtml(existingSignature, field)\n        : generateEmptyFieldHtml(field, variables)\n\n      processedHtml = processedHtml.replace(fullTag, replacementHtml)\n    }\n\n    return processedHtml\n  } catch (error) {\n    logger.error('Erreur lors du traitement des signatures', error instanceof Error ? error : new Error(String(error)), {\n      documentId,\n    })\n    // En cas d'erreur, retourner le HTML original\n    return html\n  }\n}\n\n/**\n * Parse les attributs d'une balise signature-field\n */\nfunction parseSignatureFieldAttributes(attributesString: string): SignatureField {\n  const attrs: Record<string, string> = {}\n\n  // Regex pour extraire les attributs\n  const attrRegex = /(\\w+(?:-\\w+)*)=\"([^\"]*?)\"|(\\w+(?:-\\w+)*)='([^']*?)'|(\\w+(?:-\\w+)*)=(\\S+)/g\n\n  let attrMatch\n  while ((attrMatch = attrRegex.exec(attributesString)) !== null) {\n    const key = attrMatch[1] || attrMatch[3] || attrMatch[5]\n    const value = attrMatch[2] || attrMatch[4] || attrMatch[6]\n    if (key && value) {\n      attrs[key] = value\n    }\n  }\n\n  return {\n    id: attrs.id || `signature-${Date.now()}`,\n    type: (attrs.type as any) || 'signature',\n    label: attrs.label,\n    required: attrs.required === 'true',\n    signerRole: attrs['signer-role'],\n    signerEmail: attrs['signer-email'],\n    width: attrs.width ? parseInt(attrs.width) : 200,\n    height: attrs.height ? parseInt(attrs.height) : 80,\n    page: attrs.page ? parseInt(attrs.page) : 1,\n  }\n}\n\n/**\n * Génère le HTML pour une zone de signature remplie\n */\nfunction generateSignedFieldHtml(signature: any, field: SignatureField): string {\n  const width = field.width || 200\n  const height = field.height || 80\n\n  if (field.type === 'date') {\n    const signedDate = signature.signed_at\n      ? new Date(signature.signed_at).toLocaleDateString('fr-FR', {\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric',\n        })\n      : ''\n    return `\n      <div class=\"signature-field signed\" style=\"display: inline-block; margin: 10px 0;\">\n        ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}</p>` : ''}\n        <div style=\"border: 1px solid #10b981; border-radius: 4px; padding: 8px 12px; background-color: #f0fdf4; display: inline-block;\">\n          <p style=\"margin: 0; font-size: 11pt; color: #047857; font-weight: 500;\">${signedDate}</p>\n        </div>\n      </div>\n    `\n  }\n\n  if (field.type === 'text' && signature.comment) {\n    return `\n      <div class=\"signature-field signed\" style=\"display: inline-block; margin: 10px 0;\">\n        ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}</p>` : ''}\n        <div style=\"border: 1px solid #10b981; border-radius: 4px; padding: 8px 12px; background-color: #f0fdf4; display: inline-block; min-width: ${width}px;\">\n          <p style=\"margin: 0; font-size: 11pt; color: #047857;\">${signature.comment}</p>\n        </div>\n      </div>\n    `\n  }\n\n  // Pour signature et initials, afficher l'image\n  return `\n    <div class=\"signature-field signed\" style=\"display: inline-block; margin: 10px 0;\">\n      ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}</p>` : ''}\n      <div style=\"border: 1px solid #10b981; border-radius: 4px; padding: 8px; background-color: #f0fdf4; display: inline-block;\">\n        <img\n          src=\"${signature.signature_data}\"\n          alt=\"Signature de ${signature.signer_name || 'utilisateur'}\"\n          style=\"max-width: ${width}px; max-height: ${height}px; display: block;\"\n        />\n        <p style=\"margin: 8px 0 0 0; font-size: 9pt; color: #047857; text-align: center;\">\n          Signé par ${signature.signer_name || 'utilisateur'} le ${new Date(signature.signed_at).toLocaleDateString('fr-FR')}\n        </p>\n      </div>\n    </div>\n  `\n}\n\n/**\n * Génère le HTML pour une zone de signature vide\n */\nfunction generateEmptyFieldHtml(field: SignatureField, variables: Record<string, any>): string {\n  const width = field.width || 200\n  const height = field.height || 80\n\n  // Vérifier si une variable contient déjà la signature\n  const variableKey = field.id.replace(/-/g, '_')\n  const signatureFromVariable = variables[variableKey] || variables[`signature_${variableKey}`]\n\n  if (signatureFromVariable && typeof signatureFromVariable === 'string') {\n    // Si la variable contient une image en base64 ou une URL\n    if (signatureFromVariable.startsWith('data:image') || signatureFromVariable.startsWith('http')) {\n      return `\n        <div class=\"signature-field filled-from-variable\" style=\"display: inline-block; margin: 10px 0;\">\n          ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}</p>` : ''}\n          <div style=\"border: 1px solid #3b82f6; border-radius: 4px; padding: 8px; background-color: #eff6ff; display: inline-block;\">\n            <img\n              src=\"${signatureFromVariable}\"\n              alt=\"${field.label || 'Signature'}\"\n              style=\"max-width: ${width}px; max-height: ${height}px; display: block;\"\n            />\n          </div>\n        </div>\n      `\n    }\n    // Sinon, afficher comme texte\n    return `\n      <div class=\"signature-field filled-from-variable\" style=\"display: inline-block; margin: 10px 0;\">\n        ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}</p>` : ''}\n        <div style=\"border: 1px solid #3b82f6; border-radius: 4px; padding: 8px 12px; background-color: #eff6ff; display: inline-block; min-width: ${width}px;\">\n          <p style=\"margin: 0; font-size: 11pt; color: #1e40af;\">${signatureFromVariable}</p>\n        </div>\n      </div>\n    `\n  }\n\n  // Zone vide à remplir\n  if (field.type === 'date') {\n    return `\n      <div class=\"signature-field empty\" style=\"display: inline-block; margin: 10px 0;\">\n        ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}${field.required ? ' <span style=\"color: #ef4444;\">*</span>' : ''}</p>` : ''}\n        <div style=\"border: 2px dashed #d1d5db; border-radius: 4px; padding: 8px 12px; background-color: #f9fafb; display: inline-block; min-width: 150px;\">\n          <p style=\"margin: 0; font-size: 10pt; color: #9ca3af; text-align: center;\">Date à remplir</p>\n        </div>\n      </div>\n    `\n  }\n\n  if (field.type === 'text') {\n    return `\n      <div class=\"signature-field empty\" style=\"display: inline-block; margin: 10px 0; width: 100%; max-width: 400px;\">\n        ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}${field.required ? ' <span style=\"color: #ef4444;\">*</span>' : ''}</p>` : ''}\n        <div style=\"border: 2px dashed #d1d5db; border-radius: 4px; padding: 12px; background-color: #f9fafb; min-height: 60px;\">\n          <p style=\"margin: 0; font-size: 10pt; color: #9ca3af;\">Texte à remplir</p>\n        </div>\n      </div>\n    `\n  }\n\n  // Signature ou initials\n  return `\n    <div class=\"signature-field empty\" style=\"display: inline-block; margin: 10px 0;\">\n      ${field.label ? `<p style=\"font-size: 10pt; color: #666; margin: 0 0 5px 0;\">${field.label}${field.required ? ' <span style=\"color: #ef4444;\">*</span>' : ''}</p>` : ''}\n      <div style=\"border: 2px dashed #d1d5db; border-radius: 4px; padding: 12px; background-color: #f9fafb; width: ${width}px; height: ${height}px; display: flex; align-items: center; justify-content: center;\">\n        <svg width=\"48\" height=\"48\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#9ca3af\" stroke-width=\"1.5\" style=\"opacity: 0.5;\">\n          <path d=\"M16 3.13a4 4 0 0 1 0 7.75\" />\n          <path d=\"M3 20.05V5.5a2.5 2.5 0 0 1 5 0V20.05\" />\n          <path d=\"M7 13.5h9.5\" />\n          <path d=\"M20 20.5V10.5a2.5 2.5 0 0 0-5 0V20.5\" />\n        </svg>\n      </div>\n      ${field.signerRole || field.signerEmail ? `<p style=\"margin: 5px 0 0 0; font-size: 9pt; color: #6b7280;\">${field.signerRole || field.signerEmail}</p>` : ''}\n    </div>\n  `\n}\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"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","ignoreList":[9,10]}
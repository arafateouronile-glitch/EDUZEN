{"version":3,"sources":["../../../lib/utils/document-generation/conditional-processor.ts"],"sourcesContent":["/**\n * Traite les conditions conditionnelles dans le HTML\n * Supporte les syntaxes : {IF variable}...{ENDIF}, {IF variable}...{ELSE}...{ENDIF}\n */\n\nexport interface DocumentVariables {\n  [key: string]: any\n}\n\n/**\n * Traite les conditions IF/ELSE/ENDIF dans le HTML\n * Supporte aussi la syntaxe JSX : {variable && ...}\n */\nexport function processConditionals(html: string, variables: DocumentVariables): string {\n  if (!html) return html\n\n  let result = html\n\n  // 1. Traiter la syntaxe JSX : {variable && <tag>...</tag>}\n  // Utiliser un parser qui gère correctement les balises HTML imbriquées\n  const processJSXConditionals = (text: string): string => {\n    let processed = text\n    let changed = true\n    let iterations = 0\n    const maxIterations = 10\n    \n    while (changed && iterations < maxIterations) {\n      changed = false\n      iterations++\n      \n      // Trouver toutes les occurrences de {variable && ...\n      const pattern = /\\{([a-zA-Z_][a-zA-Z0-9_]*)\\s+&&\\s+/g\n      let match\n      const replacements: Array<{ start: number; end: number; replacement: string }> = []\n      \n      // Trouver toutes les correspondances et les traiter de droite à gauche\n      const matches: Array<{ varName: string; start: number; varEnd: number }> = []\n      while ((match = pattern.exec(processed)) !== null) {\n        matches.push({\n          varName: match[1].trim(),\n          start: match.index,\n          varEnd: match.index + match[0].length,\n        })\n      }\n      \n      // Traiter de droite à gauche pour préserver les indices\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const m = matches[i]\n        let depth = 1 // On est déjà dans une accolade ouvrante\n        let pos = m.varEnd\n        let inString = false\n        let stringChar = ''\n        let foundEnd = false\n        let endPos = -1\n        \n        // Chercher la fin de la conditionnelle en gérant les accolades imbriquées et les strings\n        while (pos < processed.length && !foundEnd) {\n          const char = processed[pos]\n          \n          if (!inString) {\n            if (char === '\"' || char === \"'\") {\n              inString = true\n              stringChar = char\n            } else if (char === '{') {\n              depth++\n            } else if (char === '}') {\n              depth--\n              if (depth === 0) {\n                foundEnd = true\n                endPos = pos\n              }\n            }\n          } else {\n            if (char === stringChar && processed[pos - 1] !== '\\\\') {\n              inString = false\n            }\n          }\n          \n          pos++\n        }\n        \n        if (foundEnd && endPos > m.start) {\n          const varName = m.varName\n          const content = processed.substring(m.varEnd, endPos)\n          const value = variables[varName]\n          const conditionValue = Boolean(value) && value !== '' && value !== 0 && value !== '0' && value !== null && value !== undefined\n          \n          if (conditionValue) {\n            replacements.push({\n              start: m.start,\n              end: endPos + 1,\n              replacement: content,\n            })\n            changed = true\n          } else {\n            replacements.push({\n              start: m.start,\n              end: endPos + 1,\n              replacement: '',\n            })\n            changed = true\n          }\n        }\n      }\n      \n      // Appliquer les remplacements de droite à gauche\n      for (const rep of replacements) {\n        processed = processed.substring(0, rep.start) + rep.replacement + processed.substring(rep.end)\n      }\n    }\n    \n    return processed\n  }\n\n  result = processJSXConditionals(result)\n\n  // 2. Traiter aussi les conditionnels avec plusieurs variables : {var1 && var2 && ...}\n  const processMultiConditionals = (text: string): string => {\n    let processed = text\n    let changed = true\n    let iterations = 0\n    const maxIterations = 10\n    \n    while (changed && iterations < maxIterations) {\n      changed = false\n      iterations++\n      \n      const pattern = /\\{([a-zA-Z_][a-zA-Z0-9_]*)\\s+&&\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+&&\\s+([^}]+)\\}/g\n      \n      processed = processed.replace(pattern, (match, var1, var2, content) => {\n        const val1 = variables[var1.trim()]\n        const val2 = variables[var2.trim()]\n        const conditionValue = Boolean(val1) && val1 !== '' && Boolean(val2) && val2 !== ''\n        \n        if (conditionValue) {\n          changed = true\n          return content\n        }\n        return ''\n      })\n    }\n    \n    return processed\n  }\n\n  result = processMultiConditionals(result)\n\n  // 3. Traiter la syntaxe IF/ELSE/ENDIF classique\n  const conditionalPattern = /\\{IF\\s+([^}]+)\\}([\\s\\S]*?)(?:\\{ELSE\\}([\\s\\S]*?))?\\{ENDIF\\}/gi\n\n  result = result.replace(conditionalPattern, (match, condition, ifContent, elseContent = '') => {\n    // Évaluer la condition\n    const conditionValue = evaluateCondition(condition.trim(), variables)\n    \n    // Retourner le contenu approprié\n    return conditionValue ? ifContent : elseContent\n  })\n\n  return result\n}\n\n/**\n * Alias pour processConditionals (utilisé par html-generator)\n */\nexport const evaluateConditionalContent = processConditionals\n\n// Export par défaut pour compatibilité\nexport default processConditionals\n\n/**\n * Évalue une condition\n */\nfunction evaluateCondition(condition: string, variables: DocumentVariables): boolean {\n  // Supprimer les espaces\n  condition = condition.trim()\n\n  // Vérifier si c'est une variable simple\n  if (variables.hasOwnProperty(condition)) {\n    const value = variables[condition]\n    // Considérer comme vrai si la valeur existe et n'est pas vide/false/0\n    return Boolean(value) && value !== '' && value !== 0 && value !== '0'\n  }\n\n  // Vérifier les opérateurs de comparaison\n  const operators = ['==', '!=', '>', '<', '>=', '<=']\n  \n  for (const op of operators) {\n    if (condition.includes(op)) {\n      const [left, right] = condition.split(op).map(s => s.trim())\n      const leftValue = getVariableValue(left, variables)\n      const rightValue = getVariableValue(right, variables)\n      \n      switch (op) {\n        case '==':\n          return leftValue == rightValue\n        case '!=':\n          return leftValue != rightValue\n        case '>':\n          return Number(leftValue) > Number(rightValue)\n        case '<':\n          return Number(leftValue) < Number(rightValue)\n        case '>=':\n          return Number(leftValue) >= Number(rightValue)\n        case '<=':\n          return Number(leftValue) <= Number(rightValue)\n        default:\n          return false\n      }\n    }\n  }\n\n  // Par défaut, retourner false\n  return false\n}\n\n/**\n * Récupère la valeur d'une variable ou retourne la valeur littérale\n */\nfunction getVariableValue(expression: string, variables: DocumentVariables): any {\n  expression = expression.trim()\n  \n  // Si c'est une chaîne entre guillemets, retourner la valeur sans guillemets\n  if ((expression.startsWith('\"') && expression.endsWith('\"')) ||\n      (expression.startsWith(\"'\") && expression.endsWith(\"'\"))) {\n    return expression.slice(1, -1)\n  }\n  \n  // Si c'est un nombre, retourner le nombre\n  if (!isNaN(Number(expression))) {\n    return Number(expression)\n  }\n  \n  // Sinon, chercher dans les variables\n  return variables[expression] ?? expression\n}\n"],"names":[],"mappings":"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"}